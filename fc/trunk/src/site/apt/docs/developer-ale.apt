       ------
                                    Application Layer Events
                                    ------
                                    ------


Application Layer Events

* Content

	[[1]] {{{#Overview}Overview}}
	
	[[2]] {{{#EventCycle}EventCycle modification}}
	
	[[3]] {{{#Client}Client Subscription}}
	
	[[4]] {{{#WSDL}WSDL interface}}

	[[5]] {{{#ServiceBinding}ServiceBinding}}
	
	[[6]] {{{#LRSpec}xml LRSpec - xml format for an LRSpec}}
	
	[[7]] {{{#reader}xml String[] reader - xml format for an 
		array of logical readers}}

	[[8]] {{{#properties}xml LRProperty[] properties - xml format for 
		an array of LRProperty}}

	[[9]] {{{#Status}Status}}
	
	
* Objective

	This document shall give a short overview to the ALE class from the 
	Accada filtering and collection , to the ALEServicePort and 
	to the ALEServiceBinding.


* {Overview}

	The Ale is the responsible class for the communication with the 
	applications of the Layer above. It provides: 
	 
	* Interface for the definition and modification of EventCycles
	
	* Subscription/unsubscription of report notifications
	
	* Administrative methods (eg. VendorVersion).
	
	[]
	
	The ALEServicePort provides the interface that allows 
	clients to connect to the ALE. The service port provides:
	
	* Serialization and deserialization of ECSpecs, LRSpecs 
		and other control messages.
	
	* Binding from the interface to the actual implementation 
		of the ALE and the LogicalReaderManager
	[]
	
* {EventCycle} modification

	The ALE provides the following methods to create or modify EventCycles:
	 
	* define: Define takes a two parameters, a name for the EventCycle to 
		be created and an ECSpec for the definition of the EventCycle.
	
	* undefine: When you want to destroy an EventCycle you can call this 
		method with the appropriate name for the EventCycle to be 
		destroyed.
	
	* getECSpecNames: Returns the names of all EventCycles available in 
		the ALE.

* {Client} Subscription
	
	Whenever a client wants to use an ALE service it has to register.
	
	* subscribe: A notificationURI will be subscribed to one of the 
		EventCycles. The EventCycle can be selected through the 
		parameter specName.
	
	* unsubscribe: When a client does no more need the service of an 
		EventCycle it can unsubscribe the notifcationURI.
	
	* getSubscribers: Returns a list of all subscribers for the EventCycle 
		specified.

	
* {WSDL} interface
	
	The interface to the ALE and to the LogicalReaderManager 
	is modelled in the WebServices Description Language WSDL. 
	
	The interface basically describes the methods that are 
	available on the webservice. Consequently the messages 
	 that are exchanged (this includes even Exceptions) are 
	modelled in the wsdl as well.

	This guide will not discuss how a wsdl-file has to be written. For 
	further information refer to {{{http://ws.apache.org/axis}Apache axis}}. 
	This guide just gives a short explanation how the java stubs can be 
	created out of the wsdl file and what changes have to be done to the 
	generated stubs.
	
** Advice

	For technical references you can refer to the w3c standard 
	documentation for wsdl 1.1: 
	{{{#http://www.w3.org/TR/wsdl} http://www.w3.org/TR/wsdl }}
	
	There are many bogus "how to" in the internet. If 
	you ever encounter a problem with the serialization 
	of an xml i advice the following procedure:
	
		* Write a handcrafted java-class holding all the parameters 
			that shall be serialized.
			
		* Add a specific serializer/deserializer to the SerializerUtils 
			(see org.accada.ale.util.SerializerUtil).
		
		* Call that serializer/deserializer and look at the xml 
			that is generated.
	
** Requirements
	
	* A working copy of Apache Axis: 
		{{{http://ws.apache.org/axis}Apache axis}}
	
	* The EPC base xsd definition: {{{../files/EPCGlobal.xsd}EPCGlobal.xsd}}
		
	* The accada xsd definitions: {{{../files/ALE.xsd}ALE.xsd}}
	
	* The accada logical reader xsd definitions: 
		{{{../files/ALElr.xsd}ALElr.xsd}}
	
	* The accada ALEServiceport wsdl definition: 
		{{{../files/ALEServicePort.wsdl}ALEServicePort.wsdl}}
	
	[]
	
** Compiling
	
	To compile the wsdl file you need 
	{{{http://ws.apache.org/axis}Apache axis}}. Make sure NOT to use 
	Apache axis2. The generated stubs slightly differ from the stubs 
	generated by version 1 and likewise break the existing 
	ALEServiceBinding.
	
	Side remark: Apache axis2 supports a version 1 compatibility 
	flag. To the time when we tried out axis version 2 this 
	compatibility flag did NOT work as expected.
	
	Compile the wsdl:
	
+---+
java -cp axis.jar org.apache.axis.wsdl.WSDL2Java --all --output . \
	--server-side --verbose --skeletonDeploy true ALEServicePort.wsdl
+---+

	The flags in detail:
	
	* "--all": generate code for all elements, even unreferenced ones
	
	* "--output ." : output directory for emitted files. Store them 
		to the current directory
	
	* "--server-side": create the service-side bindings for the webservice
	
	* "--skeletonDeploy false": deploy implementation in deploy.wsdl
	
	[]
	
	Two folders are created:
	
	1. xsd: This folder contains the stubs for the datatypes used 
	in the Filtering and Collection server.
	
	2. wsdl: This folder contains the stubs for the webservice.

	Unfortunately axis does not provide a way to prepend 
	a package-name to the generated packages. The packages 
	generated by axis are "_1.org.wsdl.ale.epcglobal" for all 
	wsdl related classes and "_1.xsd.ale.epcglobal" for all 
	xsd related classes. Inside the accada fc-commons the 
	package name has to be "org.accada.ale.xsd.ale.epcglobal" 
	for xsd and "org.accada.ale.wsdl.ale.epcglobal" for wsdl. 
	To fix the package name use a code-refactoring tool (eg. eclipse). 
	Make sure that not just the package-names are refactored but 
	also the refered strings inside the serializers!
	
	
** Extending the WSDL interface

	You can easily extend the wsdl interface with new 
	methods:
	
	* <wsdl:types>: within this element you can define 
		new types accessible in the wsdl (this includes input 
		parameters, return values, exceptions ...)
		
	[]
		
+---+		
Example: SecurityException:

<xsd:element name="SecurityException" type="impl:SecurityException"/>
<xsd:complexType name="SecurityException">
	<xsd:complexContent>
		<xsd:extension base="impl:ALEException"/>
	</xsd:complexContent>
</xsd:complexType>
+---+

	* <wsdl:message>: with the <wsdl:message>-tag 
		you describe a message.

	[]
		
+---+
Example: InUseException:

<wsdl:message name="InUseExceptionResponse">
	<wsdl:part name="fault" element="impl:InUseException"/>
</wsdl:message>	
+---+
	
	* <wsdl:portType>: this section describes the methods 
		in detail including parameters, return values and 
		exceptions.

	[]
		
+---+
Example: getLRSpec:

<wsdl:operation name="getLRSpec">
	<wsdl:input message="impl:getLRSpecRequest" name="getLRSpecRequest"/>
	<wsdl:output message="impl:getLRSpecResponse" 
		name="getLRSpecResponse"/>
	<wsdl:fault message="impl:NoSuchNameExceptionResponse"
			  name="NoSuchNameExceptionFault"/>
	<wsdl:fault message="impl:SecurityExceptionResponse"
			  name="SecurityExceptionFault"/>
	<wsdl:fault message="impl:ImplementationExceptionResponse"
			  name="ImplementationExceptionFault"/>
</wsdl:operation>
+---+
		

	* <wsdl:binding> : This glues the parts together into 
	the binding interface. All the methods you provide 
	here are later on accessible through the service port

	[]
	
+---+
Example: undefine:

<wsdl:operation name="undefine"> 
	<wsdlsoap:operation soapAction=""/> 
	<wsdl:input name="undefineRequest"> 
	   <wsdlsoap:body use="literal"/> 
	</wsdl:input> 
	<wsdl:output name="undefineResponse"> 
	   <wsdlsoap:body use="literal"/> 
	</wsdl:output> 
	<wsdl:fault name="NoSuchNameExceptionFault"> 
	   <wsdlsoap:fault name="NoSuchNameExceptionFault" use="literal"/> 
	</wsdl:fault> 
	<wsdl:fault name="SecurityExceptionFault"> 
	   <wsdlsoap:fault name="SecurityExceptionFault" use="literal"/> 
	</wsdl:fault> 
	<wsdl:fault name="ImplementationExceptionFault"> 
	   <wsdlsoap:fault name="ImplementationExceptionFault" use="literal"/> 
	</wsdl:fault> 
</wsdl:operation> 
+---+


	

* {ServiceBinding}

	The stubs described in the former chapter are used for the 
	communication between two services. However the binding 
	from these stubs to the actual implementation of the ALE or 
	the LogicalReaderManager has to be defined explicitly. This 
	task is performed by the ALEServiceBinding.
	
	For each method defined in 
	{{{../files/ALEServicePort.wsdl}ALEServicePort.wsdl}} there exists a 
	method in the java file ALEServiceBindingImpl. Whenever 
	a client calls a method on its local method stub, the messages 
	involved get serialized into xml, sent over the communication channel 
	and then deserialized by the server stub. The stub then calls 
	the corresponding method on the ALEServiceBindingImpl. The 
	ALEServiceBindingImpl reformatts the incomming message 
	(if necessary) and calls the ALE or the LogicalReaderManager 
	accordingly.
	
+---+
example for getPropertyValue:

	public java.lang.String getPropertyValue(
		org.accada.ale.wsdl.ale.epcglobal.GetPropertyValue parms) 
	throws java.rmi.RemoteException, 
		org.accada.ale.wsdl.ale.epcglobal.NoSuchNameException, 
		org.accada.ale.wsdl.ale.epcglobal.ImplementationException, 
		org.accada.ale.wsdl.ale.epcglobal.SecurityException 
	{
		return LogicalReaderManager.getPropertyValue(
			parms.getName(), 
			parms.getPropertyName());
	}
+---+

	You need to implement all the methods that shall be 
	provided to clients in the ALEServiceBindingImpl.





* xml String[] {LRSpec} - xml format for an LRSpec
	
	The format of the xml plays a crucial role when deserializing the xml. 
	So pay attention when writing the xml!
	
	An LRSpec consists of 4 elements:
	
	* isComposite: tells whether the reader is composite or not
	
	* readers: array of logical readers
	
	* properties: array of LRProperty
	
	* extension: Vendor extension of an LRSpec. NEVER forget this part 
		in the accada LRSpec as it contains type-information for the 
		LogicalReaderManager when creating a new logical reader.
		
	[]
	In following there are 3 sample xml  that illustrate how you have to 
	define the different element:
	
** LRSpec for a CompositeReader:

	{{{../files/CompositeReader1.xml}CompositeReader1.xml}}

+---+
<?xml version="1.0" encoding="UTF-8"?>
<ns1:LRSpec xmlns:ns1="urn:epcglobal:ale:xsd:1">
	<isComposite xsi:type="xsd:boolean" 
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
		xmlns:xsd="http://www.w3.org/2001/XMLSchema">true</isComposite>
	
	<readers xsi:type="ns1:LRLogicalReaders" 
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
		<logicalReader xsi:type="xsd:string" 
			xmlns:xsd="http://www.w3.org/2001/XMLSchema">
				HALReader</logicalReader>
		<logicalReader xsi:type="xsd:string" 
			xmlns:xsd="http://www.w3.org/2001/XMLSchema">
				RPReader</logicalReader>
	</readers>
	
	<properties xsi:type="ns1:LRProperties" 
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
		<property xsi:type="ns1:LRProperty">
			<name xsi:type="xsd:string" 
				xmlns:xsd="http://www.w3.org/2001/XMLSchema">
					Description</name>
			<value xsi:type="xsd:string" 
				xmlns:xsd="http://www.w3.org/2001/XMLSchema">
					CompositeReader consisting of 2 
					BaseReaders and 1 CompositeReader 
					created during system startup</value>
		</property>
	</properties>
	
	<extension xsi:type="ns1:LRSpecExtension" 
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
		<readerType xsi:type="xsd:string" 
			xmlns:xsd="http://www.w3.org/2001/XMLSchema">
				org.accada.ale.server.readers.CompositeReader
		</readerType>
	</extension>
</ns1:LRSpec>
+---+

	* This reader is a composite reader and therefor the flag isComposite 
		is set to true
	
	* CompositeReader contain other readers. Therefor the logicalReaders 
		inside this CompositeReader are specified.
	
	* Properties contains 1 name-value pairs. Here only a description of 
		the reader.
	
	* extension contains the reader type that is used in the 
		LogicalReaderManager to reflect the java-class.
	

** LRSpec for a HAL reader

	{{{../files/HALReader.xml}HALReader.xml}}
	
+---+
<?xml version="1.0" encoding="UTF-8"?>
<ns1:LRSpec xmlns:ns1="urn:epcglobal:ale:xsd:1">
	<isComposite xsi:type="xsd:boolean" 
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
			xmlns:xsd="http://www.w3.org/2001/XMLSchema">
				false</isComposite>
	
	<readers xsi:type="ns1:LRLogicalReaders" 
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"/>
	
	<properties xsi:type="ns1:LRProperties" 
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
		<property xsi:type="ns1:LRProperty">
			<name xsi:type="xsd:string" 
				xmlns:xsd="http://www.w3.org/2001/XMLSchema">
					Description</name>
			<value xsi:type="xsd:string" 
				xmlns:xsd="http://www.w3.org/2001/XMLSchema">
				   HAL reader created during system startup
			</value>
		</property>
		<property xsi:type="ns1:LRProperty">
		   <name xsi:type="xsd:string" 
		   	xmlns:xsd="http://www.w3.org/2001/XMLSchema">
				PhysicalReaderName</name>
		   <value xsi:type="xsd:string" 
		   	xmlns:xsd="http://www.w3.org/2001/XMLSchema">
				MyReader</value>
		  </property>
		<property xsi:type="ns1:LRProperty">
			<name xsi:type="xsd:string" 
				xmlns:xsd="http://www.w3.org/2001/XMLSchema">
					ReadTimeInterval</name>
			<value xsi:type="xsd:string" 
				xmlns:xsd="http://www.w3.org/2001/XMLSchema">
					1000</value>
		</property>
		<property xsi:type="ns1:LRProperty">
			<name xsi:type="xsd:string" 
				xmlns:xsd="http://www.w3.org/2001/XMLSchema">
					ReadPoints</name>
			<value xsi:type="xsd:string" 
				xmlns:xsd="http://www.w3.org/2001/XMLSchema">
					Shelf1,Shelf2</value>
		</property>
		<property xsi:type="ns1:LRProperty">
			<name xsi:type="xsd:string" 
				xmlns:xsd="http://www.w3.org/2001/XMLSchema">
					PropertiesFile</name>
			<value xsi:type="xsd:string" 
				xmlns:xsd="http://www.w3.org/2001/XMLSchema">
					/props/SimulatorController.xml</value>
		</property>
	</properties>
	
	<extension xsi:type="ns1:LRSpecExtension" 
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
		<readerType xsi:type="xsd:string" 
			xmlns:xsd="http://www.w3.org/2001/XMLSchema">
				org.accada.ale.server.readers.hal.HALAdaptor
		</readerType>
	</extension>
</ns1:LRSpec>
+---+

		* As this reader is a HAL reader the flag isComposite is set 
			to false. 
		
		* The reader is a BaseReader and therefor element readers does 
			not contain any readers.
		
		* Properties contains 5 name-value pairs. Please refer to the 
			chapter "Implement an Adaptor" for further reading
		
		* extension contains the reader type that is used in the 
			LogicalReaderManager to reflect the java-class.
		
	

** LRSpec for a reader protocoll reader

	{{{../files/RPReader.xml}RPReader.xml}}

+---+
<?xml version="1.0" encoding="UTF-8"?>
<ns1:LRSpec xmlns:ns1="urn:epcglobal:ale:xsd:1">
	<isComposite xsi:type="xsd:boolean" 
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
			xmlns:xsd="http://www.w3.org/2001/XMLSchema">
				false</isComposite>
	
	<readers xsi:type="ns1:LRLogicalReaders" 
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"/>
	
	<properties xsi:type="ns1:LRProperties" 
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
		<property xsi:type="ns1:LRProperty">
			<name xsi:type="xsd:string" 
				xmlns:xsd="http://www.w3.org/2001/XMLSchema">
					Description</name>
			<value xsi:type="xsd:string" 
				xmlns:xsd="http://www.w3.org/2001/XMLSchema">
					This Logical Reader consists of shelf 1 
					and shelf 2,3,4 of the physical reader 
					named MyReader.
			</value>
		</property>
		<property xsi:type="ns1:LRProperty">
			<name xsi:type="xsd:string" 
				xmlns:xsd="http://www.w3.org/2001/XMLSchema">
					ConnectionPoint</name>
			<value xsi:type="xsd:string" 
				xmlns:xsd="http://www.w3.org/2001/XMLSchema">
					http://localhost:8000</value>
		</property>
		<property xsi:type="ns1:LRProperty">
			<name xsi:type="xsd:string" 
				xmlns:xsd="http://www.w3.org/2001/XMLSchema">
					NotificationPoint</name>
			<value xsi:type="xsd:string" 
				xmlns:xsd="http://www.w3.org/2001/XMLSchema">
					http://localhost:9090</value>
		</property>
		<property xsi:type="ns1:LRProperty">
			<name xsi:type="xsd:string" 
				xmlns:xsd="http://www.w3.org/2001/XMLSchema">
					ReadTimeInterval</name>
			<value xsi:type="xsd:string" 
				xmlns:xsd="http://www.w3.org/2001/XMLSchema">
					200</value>
		</property>
		<property xsi:type="ns1:LRProperty">
			<name xsi:type="xsd:string" 
				xmlns:xsd="http://www.w3.org/2001/XMLSchema">
					PhysicalReaderName</name>
			<value xsi:type="xsd:string" 
				xmlns:xsd="http://www.w3.org/2001/XMLSchema">
					MyReader</value>
		</property>
		<property xsi:type="ns1:LRProperty">
			<name xsi:type="xsd:string" 
				xmlns:xsd="http://www.w3.org/2001/XMLSchema">
					PhysicalReaderSource</name>
			<value xsi:type="xsd:string" 
				xmlns:xsd="http://www.w3.org/2001/XMLSchema">
					Shelf1,Shelf2,Shelf3,Shelf4</value>
		</property>
	</properties>
	
	<extension xsi:type="ns1:LRSpecExtension" 
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
		<readerType xsi:type="xsd:string" 
			xmlns:xsd="http://www.w3.org/2001/XMLSchema">
				org.accada.ale.server.readers.rp.RPAdaptor
		</readerType>
	</extension>
</ns1:LRSpec>
+---+
	
		* As this reader is a reader protocol reader the flag 
			isComposite is set to false. 
		
		* The reader is a BaseReader and therefor element readers does 
			not contain any readers.
		
		* Properties contains 6 name-value pairs. Please refer to the 
			chapter "Implement an Adaptor" for further reading
		
		* extension contains the reader type that is used in the 
			LogicalReaderManager to reflect the java-class.	
	
		
		
		
		
		
* xml String[] {reader} - xml format for an array of logical readers

	The format of the xml plays a crucial role when deserializing the xml. 
	So pay attention when writing the xml!

	{{{../files/LRLogicalReaders.xml}LRLogicalReaders.xml}}
	
+---+
<?xml version="1.0" encoding="utf-8"?>
<ns1:LRLogicalReaders xmlns:ns1="urn:epcglobal:ale:xsd:1">
	<logicalReader xsi:type="xsd:string" 
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
			HALReader</logicalReader>
	<logicalReader xsi:type="xsd:string" 
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
			RPReader</logicalReader>
</ns1:LRLogicalReaders>
+---+

	
* xml LRProperty[] {properties} - xml format for an array of LRProperty

	The format of the xml plays a crucial role when deserializing the xml. 
	So pay attention when writing the xml!

	An LRProperty consists of a name-value pair. Name describes the name of 
	the property and value contains the corresponding value.
	
	{{{../files/LRProperties.xml}LRProperties.xml}}
	
+---+
<?xml version="1.0" encoding="UTF-8"?>
<ns1:LRProperties xmlns:ns1="urn:epcglobal:ale:xsd:1">
	<property xsi:type="ns1:LRProperty" 
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
		<name xsi:type="xsd:string" 
			xmlns:xsd="http://www.w3.org/2001/XMLSchema">
				Property1</name>
		<value xsi:type="xsd:string" 
			xmlns:xsd="http://www.w3.org/2001/XMLSchema">
				The value for the property 1</value>
	</property>
	<property xsi:type="ns1:LRProperty" 
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
		<name xsi:type="xsd:string" 
			xmlns:xsd="http://www.w3.org/2001/XMLSchema">
				Property2</name>
		<value xsi:type="xsd:string" 
			xmlns:xsd="http://www.w3.org/2001/XMLSchema">
				The value for the property 2</value>
	</property>	
</ns1:LRProperties>
+---+


	

* {Status}

	Currently the ALE supports the functionality of the logical reader API. 
	For further reading refer to the following documents:
	 
	* {{{../features.html} Features}}
	
	* {{{../apidocs/index.html}Java doc}}

	
	
	
	
	
	
	
	
	
	
	
	
