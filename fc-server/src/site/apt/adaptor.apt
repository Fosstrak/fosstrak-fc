       ------
                                    How to implement an Adaptor
                                    ------
                                    ------


How to implement an Adaptor

* Contents

   [[1]] {{{#Objective}Objective}}

   [[2]] {{{#HALAdaptor}HALAdaptor}}
   
   [[3]] {{{#RPAdaptor}RPAdaptor}}

   [[4]] {{{#A}A new Adaptor}}


* {Objective}

	This guide is intented for developers who wish to integrate a 
	tag reader into to the Logical Reader API of the accada ALE.




* {HALAdaptor}
	
	The HALAdaptor provides an adaptor to the Hardware Abstraction Layer (HAL).
	
	The following list will show the required LRProperties that have to be 
	provided through an LRSpec when a new HAL reader shall be constructed.
	
	* ImplClass: The full path to the type of the reader. For a HALAdaptor this 
		is always "org.accada.ale.server.readers.hal.HALAdaptor".

-----------------------------------------------------------------------------------
<LRProperty name="ImplClass" value="org.accada.ale.server.readers.hal.HALAdaptor"/>
-----------------------------------------------------------------------------------
	
	* PhysicalReadername: The name of the HAL reader.
	
---------------------------------------------------------------------------------
<LRProperty name="PhysicalReaderName" value="MyReader"/>
---------------------------------------------------------------------------------	
	* ReadTimeInterval: The interval in which a HAL device shall inform the 
		HALAdaptor about new tags. If the HAL device does not provide an 
		auto-polling mechanism, the HALAdaptor will automatically create 
		a polling thread that will poll the HAL device in a regular 
		interval. The interval is in miliseconds
		
		Syntax: integer
		
---------------------------------------------------------------------------------
<LRProperty name="ReadTimeInterval" value="2000"/>
---------------------------------------------------------------------------------
	
	* PropertiesFile: All HAL devices that are currently supported, need a 
		properties file.

---------------------------------------------------------------------------------
<LRProperty name="PropertiesFile" value="/props/SimulatorController.xml"/>
---------------------------------------------------------------------------------

	* Description: This gives a general human readable description to the 
		adaptor.
	
-----------------------------------------------------------------------------------
<LRProperty name="Description" value="This is my new physical reader xyz.uvw"/>
-----------------------------------------------------------------------------------	
	
	[]
	
	A sample configuration for a HALAdaptor

+----------------------------------------------------------------------------------------------------+
<LogicalReader name="LogicalReader1">
	<LRSpec isComposite="false" readerType="org.accada.ale.server.readers.hal.HALAdaptor">
		<LRProperty name="Description" value="HAL reader created during system startup"/>
		<LRProperty name="AdaptorClass" value="HAL"/>
		<LRProperty name="ImplClass" value="org.accada.ale.server.readers.hal.HALAdaptor"/>
		<LRProperty name="PhysicalReaderName" value="MyReader"/>
		<LRProperty name="ReadTimeInterval" value="1000"/>
		<LRProperty name="PropertiesFile" value="/props/SimulatorController.xml"/>
	</LRSpec>
</LogicalReader>
+----------------------------------------------------------------------------------------------------+
	
	[]
	Currently the HALAdaptor creates a SimulatorController object. This object 
	in turn then sets up the HAL device as requested by the properties file. 

[images/readerAPI/HALAdaptor.png]

	For example properties files refer to:
	 
	* BatchSimulator.xml for a batch simulator
	
	* GraphicSimulator.xml for a graphical simulator









* {RPAdaptor}

	The RPAdaptor provides an adaptor to the reader protokoll (RP). 
	
	The following list will show the required LRProperties that 
	have to be provided through an LRSpec when a new RP reader shall 
	be constructed.
	
	* ConnectionPoint: the connection point is needed to connect to the reader. 
		The rp-proxy will connect to this url.
		
		Syntax: "proto://ip:port"
		
-----------------------------------------------------------------------------------
<LRProperty name="ConnectionPoint" value="http://localhost:8000"/>
-----------------------------------------------------------------------------------	
	
	* NotificationPoint: the notification point is used to communicate from 
		the reader to the RPAdaptor. All tags read by the reader are returned 
		over this channel.
		
		Syntax: "proto://ip:port"

-----------------------------------------------------------------------------------
<LRProperty name="NotificationPoint" value="http://localhost:9090"/>
-----------------------------------------------------------------------------------
	
	* ReadTimeInterval: the read time interval specifies how often the reader 
		informs the RPAdaptor about new tag events. The interval is 
		in miliseconds.
		
		Syntax: integer
		
-----------------------------------------------------------------------------------
<LRProperty name="ReadTimeInterval" value="2000"/>
-----------------------------------------------------------------------------------
	
	* ImplClass: the full path to the type of the reader. For a RPAdaptor this 
		is always "org.accada.ale.server.readers.rp.RPAdaptor".
	
-----------------------------------------------------------------------------------
<LRProperty name="ImplClass" value="org.accada.ale.server.readers.rp.RPAdaptor"/>
-----------------------------------------------------------------------------------
	
	* PhysicalReaderName: The name of the physical reader.
	
	* PhysicalReaderSource: This is a list of physical sources on the reader 
		device that shall send tags. 
		
		Syntax: "Antenna1,Antenna2,Antenna3"
		
-----------------------------------------------------------------------------------
<LRProperty name="PhysicalReaderSource" value="Shelf1,Shelf2,Shelf3"/>
-----------------------------------------------------------------------------------	
	
	* Description: This gives a general human readable description to the 
		adaptor.
	
-----------------------------------------------------------------------------------
<LRProperty name="Description" value="This is my new physical reader xyz.uvw"/>
-----------------------------------------------------------------------------------
	
	[]
	A sample configuration for a RPAdaptor
	
+-----------------------------------------------------------------------------------------------+
<LogicalReader name="LogicalReader1">
	<LRSpec isComposite="false" readerType="org.accada.ale.server.readers.rp.RPAdaptor">
		<LRProperty name="Description" value="My physical Reader"/>
		<LRProperty name="ConnectionPoint" value="http://localhost:8000"/>
		<LRProperty name="NotificationPoint" value="http://localhost:9090"/>
		<LRProperty name="ReadTimeInterval" value="200"/>
		<LRProperty name="AdaptorClass" value="ReaderProtocol"/>
		<LRProperty name="ImplClass" value="org.accada.ale.server.readers.rp.RPAdaptor"/>
		<LRProperty name="PhysicalReaderName" value="MyReader"/>
		<LRProperty name="PhysicalReaderSource" value="Shelf1,Shelf2,Shelf3,Shelf4"/>
	</LRSpec>
</LogicalReader>
+-----------------------------------------------------------------------------------------------

		
	[]
	The RPAdaptor provides a default constructor and an initializer method. Both 
	are called in the construction phase of the LogicalReader. The RPAdaptor 
	implements all methods that are required by the logical reader API (basically 
	these are the methods that are specified in LogicalReader and in BaseReader).
	
	Aside the standard methods and fields the RPAdaptor requires some more 
	functionality to communicate with a rp-proxy. The InputGenerator sets up 
	the connection between the RPAdaptor and the rp-proxy. There are two channels 
	that need to be created. The first one (command channel) is created for the 
	communication from the RPAdaptor to the rp-proxy. The command channel uses the 
	connection settings provided by ConnectionPoint. The second channel (notification 
	channel) is used for the communication from the rp-proxy to the RPAdaptor and 
	provides a channel for the delivery of tags from the physical reader. The 
	settings provided by NotificationPoint are used to set up this channel. As soon 
	as the RPAdaptor is started through the logical reader API the rp-proxy sends 
	tag events that are then processed by the InputGenerator and sent through the 
	RPAdaptor to the observers (CompositeReader or EventCycle).
	
[images/readerAPI/RPAdaptor.png]
	
	
	
	
	
	
	
	
	
	
	
	
	
	

* {A} new Adaptor

	When you want to integrate your own reader into the logical 
	reader API there are only few restrictions and obligations 
	you need to obey.
	
	In a first step you should create a new package for your 
	reader adaptor.
	
	Create a new class with the name of your adaptor and let 
	this class extend the class BaseReader.
	
	You need to overwrite the following methods
	
	* start: start the reader (this means only to let the reader 
		deliver tags).
	
	* stop: stop the reader (this means only to stop the reader from 
		delivering tags).
	
	* connectReader: here you should place the connection setup 
		between the reader and the reader adaptor.
	
	* disconnectReader: destroy the connection between the 
		reader and the adaptor.
	
	* identify: you must implement this method, even when you 
		do have a reader that is capable if auto-polling
	
	* update: here you have to place the code for an update 
		through the logical reader API.
	
	* initialize: this method is used to setup your adaptor 
		(see further below).
	
	[]
	Pay attention to flag the state of your adaptor correctly 
	through the methods (setConnected, setStarted, ...)
	
	Instead of a constructor with arguments we chose the 
	approach of an default constructor and an initializer method. 
	To ensure that your adaptor is setup correctly implement 
	the constructor and the initizalizer method as following:
	
	* constructor: do not implement a constructor that needs 
		arguments. Easiest is just to place the constructor 
		call for the superclass ("super()") and leave 
		the rest empty.
	 
	* initialize: The initializer-method takes two arguments. 
		The first (name: String) will be the name of 
		your reader within the logical reader API. The 
		second (spec:LRSpec) is a valid LRSpec that contains 
		the details how to build your reader.
		
		pay attention to put the call to the initializer 
		method of the superclass ("super.initialize(name, spec)"). 
		After that feel free to express yourself.
	 
	
	[]
	Now you are ready to use your reader in the logical reader 
	API.
	
	sample code of an empty reader adaptor:
	 
+------------------------------------------------------------------+
package org.accada.ale.server.readers.myreader;

import org.accada.ale.server.Tag;
import org.accada.ale.server.readers.BaseReader;
import org.accada.ale.server.readers.LRSpec;
import org.accada.ale.wsdl.ale.epcglobal.ImplementationException;
import org.accada.reader.hal.HardwareException;
import org.accada.reader.hal.Observation;

public class MyReaderAdaptor extends BaseReader {

	public MyReaderAdaptor() {
		super();
	}
	
	public void initialize(String name, LRSpec spec) throws ImplementationException {
		super.initialize(name, spec);
	}

	@Override
	public void addTag(Tag tag) {
		// TODO Auto-generated method stub

	}

	@Override
	public void connectReader() throws ImplementationException {
		// TODO Auto-generated method stub

	}

	@Override
	public void disconnectReader() throws ImplementationException {
		// TODO Auto-generated method stub

	}

	@Override
	public Observation[] identify(String[] readPointNames)
			throws HardwareException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void start() {
		// TODO Auto-generated method stub

	}

	@Override
	public void stop() {
		// TODO Auto-generated method stub

	}

	@Override
	public void update(LRSpec spec) throws ImplementationException {
		// TODO Auto-generated method stub

	}
}
+------------------------------------------------------------------+
	
	